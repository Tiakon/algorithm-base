# 1. 栈和队列

- 在Java 早期的版本中栈结构 Stack 与队列结构 LinkedList 都是基于链表（List接口和AbstractList）来实现的。
- 在之后的版本中队列结构也实现了List接口，也可以当作栈来使用：
  - 例如：ArrayDeque，是基于数组实现的双端队列、非线程安全，但是当作链表比LinkedList快，当做栈比Stack快。



**结构特点**

都基于链表。

栈    ：先进后出

队列：先进先出

双端队列：头或尾，都支持先进先出



**相关算法**

1. 设计一个得到最小值的栈 ✪
   1. 使用两个栈，栈1,栈2,栈1 保存正常值，栈2保存小于栈顶的值。
   2. 注意两个栈的push、，需要做到元素同步。
   3. 时间复杂度：O(1)
2. 用两个栈设计一个队列 ✪✪
   1. 使用两个栈 push栈、 pop栈 。
   2. add 队列时，压入push栈 
   3. poll或peek 队列时， pop栈为空与push栈非空 （保证入队列的顺序），才将 push栈全部压入 pop栈
3. 仅用递归函数和栈操作逆序一个栈 ✪✪
   1. 注意：递归函数的结束条件。
   1. 时间复杂度：O(n^2)
4. 猫狗队列 ✪
   1. 增加一个入队时间属性，用两个栈就可以实现。
5. 如何用一个栈实现另一个栈的排序（从上到下，降序排列） ✪
   1. 利用递归，每次去最小值再重新压入栈
   2. 时间复杂度：O(n^2)
6. 用栈求解汉诺塔问题 ✪✪✪
7. 获取窗口最大值 ✪✪
   1. 利用双端队列，将队列中小于数组的数全部弹出，将队头作为最大值，在遍历数组时，将下标加入队列
   2. 计算队头下标，检查是否过期（x=i-w）
   3. 将对头放入结果数组中，取队头作为窗口最大值
   4. 时间复杂度：O(n)
8. 生成MaxTree ✪✪✪
9. 单调栈结构✪✪
10. 求最大子矩阵的面积 ✪✪✪
11. 最大值减去最小值小于或等于num的子数组数量✪✪✪
12. 求可见山峰数量
    1. 输入不重复：
       1. 利用小找大原则，分别从next和last方向比较。
       2. 利用打印环形数组的方式，实现next方向上数组的任意位置环形比较。
       3. 利用栈实现last方向的比较。

    2. 输入可能会重复：






